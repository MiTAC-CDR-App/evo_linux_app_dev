/*------------------------------------------------------------------------------------------------------------*
 *                                                                                                            *
 * Copyright      2018 MiTAC International Corp.                                                              *
 *                                                                                                            *
 *------------------------------------------------------------------------------------------------------------*
 * PROJECT     :  Common Framework                                                                            *
 * BINARY NAME :  libBase                                                                                     *
 * FILE NAME   :  container/List.h                                                                            *
 * CREATED BY  :  Huah Tu <huah.tu@mic.com.tw>                                                                *
 * CREATED DATE:  07/19/18 (MM/DD/YY)                                                                         *
 * DESCRIPTION :  1. Wrap std::deque as general Java List, for beter clients' access, with some high level    *
 *                   methods.                                                                                 *
 *                2. Reference Java List<T> for most methods.                                                 *
 *                3. Not multi-thread-safe.                                                                   *
 *------------------------------------------------------------------------------------------------------------*/

#ifndef _CONTAINER_LIST_H
#define _CONTAINER_LIST_H

// Standard inlcude
#include <stdlib.h>
// STL include
#include <deque>

// Some example for comparison
// 1. List<StatusListener *>: pointer check is use.
// 2. List<Trip>: Trip::operator==(Trip &) is used.
// 3. List<int>: integer comparison is used.
template <class T>
class List
{
  public:
    // Declare it as public, for some performance requirement, for example, compare and insert at the same time.
    std::deque<T> _deque;

    int size(void) const;
    const T &get(int ndx) const;
    T &get(int ndx);
    void set(int ndx, T &obj);
    bool contains(const T &obj) const;
    int indexOf(const T &obj) const;
    bool add(const T &obj);
    bool add(int pos, const T &obj);
    // For well-considered codes, which promise no duplicaton by nature.  And more, if no add()/remove() is
    // used (that is, only addWithoutCheck()/clear() is used), T::operator=() is not required.
    void addWithoutCheck(const T &obj);
    void addWithoutCheck(int pos, const T &obj);
    bool removeObj(const T &obj);
    bool remove(const T &obj);
    void removeByIndex(int ndx);
    void remove(int ndx);
    void clear(void);
    // 1. Only for T = "XXX *" (including void *)
    // 2. free() is used, so, all items should be generated by alloc(), malloc(), strdup(), or whatever
    //    free()-able functions.
    void freeAllPtrItemsAndReset(void);
    // 1. Only for T = "XXX *" and XXX is a class (or struct by new ...).
    // 2. delete is used, so all objects should be created by new ....
    void deleteAllObjsAndReset(void);
};

template<class T>
int List<T>::size(void) const
{
    return (unsigned) _deque.size();
}

template<class T>
const T &List<T>::get(int ndx) const
{
    return _deque.at(ndx);
}

template<class T>
void List<T>::set(int ndx, T &obj)
{
    _deque.at(ndx) = obj;
}

template<class T>
T &List<T>::get(int ndx)
{
    return _deque.at(ndx);
}

template<class T>
bool List<T>::contains(const T &obj) const
{
    typename std::deque<T>::const_iterator it = _deque.begin();
    for(; it != _deque.end(); ++it)
    {
        if((*it) == obj)
        {
            return true;
        }
    }
    return false;
}

template<class T>
int List<T>::indexOf(const T &obj) const
{
    typename std::deque<T>::const_iterator it = _deque.begin();
    int ndx = 0;
    for(; it != _deque.end(); ++it, ++ndx)
    {
        if((*it) == obj)
        {
            return ndx;
        }
    }
    return -1;
}

template<class T>
bool List<T>::add(const T &obj)
{
    if(contains(obj))
    {
        return false;
    }
    _deque.push_back(obj);
    return true;
}

template<class T>
bool List<T>::add(int pos, const T &obj)
{
    if(contains(obj))
    {
        return false;
    }
    _deque.insert(_deque.begin() + pos, obj);
    return true;
}

template<class T>
void List<T>::addWithoutCheck(const T &obj)
{
    _deque.push_back(obj);
}

template<class T>
void List<T>::addWithoutCheck(int pos, const T&obj)
{
    _deque.insert(_deque.begin() + pos, obj);
}

template<class T>
bool List<T>::removeObj(const T &obj)
{
    typename std::deque<T>::iterator it = _deque.begin();
    for(; it != _deque.end(); ++it)
    {
        if(obj == *it)
        {
            _deque.erase(it);
            return true;
        }
    }
    return false;
}

template<class T>
bool List<T>::remove(const T &obj)
{
    return removeObj(obj);
}

template<class T>
void List<T>::removeByIndex(int ndx)
{
    _deque.erase(_deque.begin() + ndx);
}

template<class T>
void List<T>::remove(int ndx)
{
    removeByIndex(ndx);
}

template<class T>
void List<T>::clear(void)
{
    _deque.clear();
}

template<class T>
void List<T>::freeAllPtrItemsAndReset(void)
{
    typename std::deque<T>::iterator it = _deque.begin();
    for(; it != _deque.end(); ++it)
    {
        free((void *) *it);
    }
    _deque.clear();
}

template<class T>
void List<T>::deleteAllObjsAndReset(void)
{
    typename std::deque<T>::iterator it = _deque.begin();
    for(; it != _deque.end(); ++it)
    {
        delete (*it);
    }
    _deque.clear();
}

#endif //_CONTAINER_LIST_H
